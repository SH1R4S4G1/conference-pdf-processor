[{"C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\app\\layout.tsx":"1","C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\api\\process-pdf.ts":"2","C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\index.tsx":"3"},{"size":411,"mtime":1693728725933,"results":"4","hashOfConfig":"5"},{"size":4374,"mtime":1693671441294,"results":"6","hashOfConfig":"5"},{"size":2313,"mtime":1693738560112,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","suppressedMessages":"10","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"120nh0h",{"filePath":"11","messages":"12","suppressedMessages":"13","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14"},{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18"},"C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\app\\layout.tsx",[],[],"C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\api\\process-pdf.ts",["19"],[],"// process-pdf.ts\r\nimport { NextApiRequest, NextApiResponse } from 'next';\r\nimport { PDFDocument, rgb, StandardFonts } from 'pdf-lib';\r\nimport multer from 'multer';\r\n\r\n// multerの設定\r\nconst storage = multer.memoryStorage();\r\nconst upload = multer({ storage: storage });\r\n\r\nexport const config = {\r\n  api: {\r\n    bodyParser: false,\r\n  },\r\n};\r\n\r\ninterface MulterRequest extends NextApiRequest {\r\n  file: any;\r\n}\r\n\r\nexport default async (req: NextApiRequest, res: NextApiResponse) => {\r\n  upload.single('pdf')(req as any, res as any, async (err) => {\r\n    if (err) {\r\n      console.error('Multer error:', err);\r\n      return res.status(500).json({ error: 'Error processing file upload' });\r\n    }\r\n\r\n\r\n    try {\r\n        console.log(\"Starting PDF processing...\");\r\n\r\n        // ステップ1: PDFデータをバッファとして取得\r\n        console.log(\"Loading PDF data from request...\");\r\n        const multerReq = req as MulterRequest;\r\n        const pdfBytes = multerReq.file.buffer;  \r\n        console.log(\"Original PDF data:\", pdfBytes); // 加工前のログ      \r\n        console.log(\"Loaded PDF data successfully\");\r\n\r\n        // ステップ2: PDFを読み込む\r\n        console.log(\"Loading the PDF document...\");\r\n        const firstBytes = Array.from(pdfBytes.slice(0, 5)) as number[];\r\n        console.log(\"First bytes of received data:\", String.fromCharCode(...firstBytes));\r\n                const pdfDoc = await PDFDocument.load(pdfBytes);\r\n        console.log(\"Loaded the PDF document successfully\");\r\n\r\n        // ステップ3: フォントをロードする\r\n        console.log(\"Embedding font...\");\r\n        const font = await pdfDoc.embedFont(StandardFonts.Helvetica);\r\n        console.log(\"Font embedded successfully\");\r\n\r\n        // ステップ4: 各ページにページ番号を追加する\r\n        console.log(\"Adding page numbers...\");\r\n        const pages = pdfDoc.getPages();\r\n        for (let i = 0; i < pages.length; i++) {\r\n            const page = pages[i];\r\n            const { width } = page.getSize();\r\n            page.drawText(String(i + 1), {\r\n                x: width - 50,\r\n                y: 30,\r\n                size: 30,\r\n                font: font,\r\n                color: rgb(0, 0, 0),\r\n            });\r\n        }\r\n        console.log(\"Added page numbers successfully\");\r\n\r\n        // ステップ5: PDFをシリアライズしてUint8Arrayとして取得\r\n        console.log(\"Serializing modified PDF...\");\r\n        const modifiedPdfBytes = await pdfDoc.save();\r\n        console.log(\"Modified PDF data:\", modifiedPdfBytes); // 加工後のログ\r\n        console.log(\"Serialized modified PDF successfully\");\r\n\r\n        // ステップ6: 変更されたPDFをレスポンスとして返す\r\n        console.log(\"Setting response headers...\");\r\n        res.setHeader('Content-Type', 'application/pdf');\r\n        res.setHeader('Content-Disposition', 'attachment; filename=processed.pdf');\r\n        \r\n        console.log(\"Sending success response with modified PDF\");\r\n        res.status(200).send(Buffer.from(modifiedPdfBytes));\r\n      }\r\n        catch (error) {\r\n          console.error('Error processing PDF:', error);\r\n          console.error('Error stack trace:', (error as Error).stack);  // スタックトレースの追加\r\n          res.status(500).json({ error: 'Internal Server Error', details: (error as Error).message });\r\n      }      \r\n})};\r\n\r\n\r\n\r\n\r\n// import { NextApiRequest, NextApiResponse } from 'next';\r\n// import init, { add_page_numbers_to_pdf } from '../../wasm/pkg/wasm.js'; \r\n// //TODO: Wasmのパスを環境変数にした方がいいかも\r\n\r\n// // Wasmのためにフェッチを追加\r\n// import fetch, { RequestInfo, RequestInit, Response } from 'node-fetch';\r\n// (globalThis.fetch as unknown) = fetch;\r\n\r\n// export default async (req: NextApiRequest, res: NextApiResponse) => {\r\n//   // Wasmモジュールの初期化\r\n//   await init();\r\n\r\n//   if (req.method === 'POST') {\r\n//     try {\r\n//       const pdfBuffer = Buffer.from(req.body.pdf);\r\n//       const processedPdfData = add_page_numbers_to_pdf(pdfBuffer);\r\n\r\n//       res.status(200).send(processedPdfData);\r\n//     } catch (error) {\r\n//       res.status(500).send({ error: 'Failed to process the PDF.' });\r\n//     }\r\n//   } else {\r\n//     res.status(405).send({ error: 'Only POST requests are accepted.' });\r\n//   }\r\n// };\r\n","C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\index.tsx",["20"],[],"// function Home() {\r\n//   return <div>Hello World</div>;\r\n// }\r\n\r\n// export default Home;\r\n\r\n\r\n// index.tsx\r\nimport React, { useState } from 'react';\r\nimport axios from 'axios';\r\n\r\nexport default function Home() {\r\n  // PDFのデータとサムネイルのステート\r\n  const [pdfData, setPdfData] = useState<Blob | null>(null);\r\n  const [thumbnail, setThumbnail] = useState<string | null>(null);  \r\n\r\n  // PDFがドラッグ&ドロップされたときのハンドラ\r\n  const onDrop = async (event: React.DragEvent<HTMLDivElement>) => {\r\n    event.preventDefault();\r\n\r\n    // ドロップされたファイルを取得\r\n    const pdfFile = event.dataTransfer.files[0];\r\n    const pdfBuffer = await pdfFile.arrayBuffer();\r\n\r\n    // ファイルのデータをFormDataとしてAPIに送信\r\n    const formData = new FormData();\r\n    formData.append('pdf', new Blob([pdfBuffer]));\r\n\r\n    try {\r\n      // APIにPOSTリクエストを送信し、加工後のPDFを取得\r\n      const response = await axios.post('/api/process-pdf', formData, {\r\n        responseType: 'arraybuffer',\r\n        headers: {\r\n          'Content-Type': 'multipart/form-data'\r\n        }\r\n      });\r\n\r\n      console.log(\"API Response Content-Type:\", response.headers['content-type']);\r\n\r\n      console.log(\"API Response:\", response); // 追加されたログ\r\n      const apiResponseData = new Uint8Array(response.data);\r\n      console.log(\"API Response Data (first bytes):\", apiResponseData.slice(0, 10));\r\n\r\n      setPdfData(new Blob([response.data], { type: 'application/pdf' }));\r\n      // 実際にはサムネイルを生成するロジックが必要ですが、ダミーのサムネイルを設定\r\n      setThumbnail('04.png');\r\n    } catch (error) {\r\n      console.error(\"Error processing the PDF:\", error);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <div onDrop={onDrop} onDragOver={(e) => e.preventDefault()} style={{ border: '1px dashed', height: '200px' }}>\r\n        PDFをここにドロップ\r\n      </div>\r\n\r\n      {thumbnail && (\r\n        <div>\r\n          <img src={thumbnail} alt=\"サムネイル\" />\r\n          {/* ダウンロードリンクの修正 */}\r\n          <a href={pdfData ? URL.createObjectURL(pdfData) : '#'} download=\"edited.pdf\">ダウンロード</a>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\n",{"ruleId":"21","severity":1,"message":"22","line":20,"column":1,"nodeType":"23","endLine":85,"endColumn":5},{"ruleId":"24","severity":1,"message":"25","line":60,"column":11,"nodeType":"26","endLine":60,"endColumn":46},"import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","@next/next/no-img-element","Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element","JSXOpeningElement"]