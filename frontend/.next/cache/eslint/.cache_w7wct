[{"C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\app\\layout.tsx":"1","C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\api\\process-pdf.ts":"2","C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\index.tsx":"3","C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\api\\saveToTemp.ts":"4"},{"size":411,"mtime":1693728725933,"results":"5","hashOfConfig":"6"},{"size":4374,"mtime":1693671441294,"results":"7","hashOfConfig":"6"},{"size":3587,"mtime":1693925541125,"results":"8","hashOfConfig":"6"},{"size":593,"mtime":1693752097199,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","suppressedMessages":"12","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"120nh0h",{"filePath":"13","messages":"14","suppressedMessages":"15","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16"},{"filePath":"17","messages":"18","suppressedMessages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23"},"C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\app\\layout.tsx",[],[],"C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\api\\process-pdf.ts",["24"],[],"// process-pdf.ts\r\nimport { NextApiRequest, NextApiResponse } from 'next';\r\nimport { PDFDocument, rgb, StandardFonts } from 'pdf-lib';\r\nimport multer from 'multer';\r\n\r\n// multerの設定\r\nconst storage = multer.memoryStorage();\r\nconst upload = multer({ storage: storage });\r\n\r\nexport const config = {\r\n  api: {\r\n    bodyParser: false,\r\n  },\r\n};\r\n\r\ninterface MulterRequest extends NextApiRequest {\r\n  file: any;\r\n}\r\n\r\nexport default async (req: NextApiRequest, res: NextApiResponse) => {\r\n  upload.single('pdf')(req as any, res as any, async (err) => {\r\n    if (err) {\r\n      console.error('Multer error:', err);\r\n      return res.status(500).json({ error: 'Error processing file upload' });\r\n    }\r\n\r\n\r\n    try {\r\n        console.log(\"Starting PDF processing...\");\r\n\r\n        // ステップ1: PDFデータをバッファとして取得\r\n        console.log(\"Loading PDF data from request...\");\r\n        const multerReq = req as MulterRequest;\r\n        const pdfBytes = multerReq.file.buffer;  \r\n        console.log(\"Original PDF data:\", pdfBytes); // 加工前のログ      \r\n        console.log(\"Loaded PDF data successfully\");\r\n\r\n        // ステップ2: PDFを読み込む\r\n        console.log(\"Loading the PDF document...\");\r\n        const firstBytes = Array.from(pdfBytes.slice(0, 5)) as number[];\r\n        console.log(\"First bytes of received data:\", String.fromCharCode(...firstBytes));\r\n                const pdfDoc = await PDFDocument.load(pdfBytes);\r\n        console.log(\"Loaded the PDF document successfully\");\r\n\r\n        // ステップ3: フォントをロードする\r\n        console.log(\"Embedding font...\");\r\n        const font = await pdfDoc.embedFont(StandardFonts.Helvetica);\r\n        console.log(\"Font embedded successfully\");\r\n\r\n        // ステップ4: 各ページにページ番号を追加する\r\n        console.log(\"Adding page numbers...\");\r\n        const pages = pdfDoc.getPages();\r\n        for (let i = 0; i < pages.length; i++) {\r\n            const page = pages[i];\r\n            const { width } = page.getSize();\r\n            page.drawText(String(i + 1), {\r\n                x: width - 50,\r\n                y: 30,\r\n                size: 30,\r\n                font: font,\r\n                color: rgb(0, 0, 0),\r\n            });\r\n        }\r\n        console.log(\"Added page numbers successfully\");\r\n\r\n        // ステップ5: PDFをシリアライズしてUint8Arrayとして取得\r\n        console.log(\"Serializing modified PDF...\");\r\n        const modifiedPdfBytes = await pdfDoc.save();\r\n        console.log(\"Modified PDF data:\", modifiedPdfBytes); // 加工後のログ\r\n        console.log(\"Serialized modified PDF successfully\");\r\n\r\n        // ステップ6: 変更されたPDFをレスポンスとして返す\r\n        console.log(\"Setting response headers...\");\r\n        res.setHeader('Content-Type', 'application/pdf');\r\n        res.setHeader('Content-Disposition', 'attachment; filename=processed.pdf');\r\n        \r\n        console.log(\"Sending success response with modified PDF\");\r\n        res.status(200).send(Buffer.from(modifiedPdfBytes));\r\n      }\r\n        catch (error) {\r\n          console.error('Error processing PDF:', error);\r\n          console.error('Error stack trace:', (error as Error).stack);  // スタックトレースの追加\r\n          res.status(500).json({ error: 'Internal Server Error', details: (error as Error).message });\r\n      }      \r\n})};\r\n\r\n\r\n\r\n\r\n// import { NextApiRequest, NextApiResponse } from 'next';\r\n// import init, { add_page_numbers_to_pdf } from '../../wasm/pkg/wasm.js'; \r\n// //TODO: Wasmのパスを環境変数にした方がいいかも\r\n\r\n// // Wasmのためにフェッチを追加\r\n// import fetch, { RequestInfo, RequestInit, Response } from 'node-fetch';\r\n// (globalThis.fetch as unknown) = fetch;\r\n\r\n// export default async (req: NextApiRequest, res: NextApiResponse) => {\r\n//   // Wasmモジュールの初期化\r\n//   await init();\r\n\r\n//   if (req.method === 'POST') {\r\n//     try {\r\n//       const pdfBuffer = Buffer.from(req.body.pdf);\r\n//       const processedPdfData = add_page_numbers_to_pdf(pdfBuffer);\r\n\r\n//       res.status(200).send(processedPdfData);\r\n//     } catch (error) {\r\n//       res.status(500).send({ error: 'Failed to process the PDF.' });\r\n//     }\r\n//   } else {\r\n//     res.status(405).send({ error: 'Only POST requests are accepted.' });\r\n//   }\r\n// };\r\n","C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\index.tsx",["25"],[],"C:\\Users\\devuser\\OneDrive\\dev\\Conference-pdf-processor\\frontend\\src\\pages\\api\\saveToTemp.ts",["26"],[],"import { NextApiRequest, NextApiResponse } from 'next';\r\nimport * as os from 'os';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport default (req: NextApiRequest, res: NextApiResponse) => {\r\n  if (req.method === 'POST') {\r\n    const fileData = req.body;\r\n    const tempDir = os.tmpdir();\r\n    const filePath = path.join(tempDir, 'some_unique_filename.pdf');  // TODO: ユニークなファイル名を生成\r\n\r\n    fs.writeFileSync(filePath, fileData);\r\n\r\n    res.status(200).json({ path: filePath });\r\n  } else {\r\n    res.status(405).end();  // Method Not Allowed\r\n  }\r\n};\r\n",{"ruleId":"27","severity":1,"message":"28","line":20,"column":1,"nodeType":"29","endLine":85,"endColumn":5},{"ruleId":"30","severity":1,"message":"31","line":75,"column":11,"nodeType":"32","endLine":75,"endColumn":46},{"ruleId":"27","severity":1,"message":"28","line":6,"column":1,"nodeType":"29","endLine":18,"endColumn":3},"import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","@next/next/no-img-element","Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element","JSXOpeningElement"]